# Интеллектуальный Мультибанковский Финансовый Советник (ИМФС)

Наш проект — это ваш персональный финансовый советник с **искусственным интеллектом на базе больших языковых моделей (LLM)**, созданный для того, чтобы дать вам полный контроль над вашими финансами и помочь принимать взвешенные решения. Приложение агрегирует финансовые данные из различных банков, анализирует их с помощью ИИ-агентов и предоставляет персонализированные рекомендации. Архитектура проекта построена на принципах многослойности и разделения ответственности, включая слои для API-взаимодействия (`app/api`), агрегации данных из множества банков (`app/mcp`), интеграции LLM (`app/llm_integration`), работы с базой данных (`app/db`), определения схем данных (`app/schemas`) и взаимодействия с внешними банковскими API (`app/banks`).

**Ключевые преимущества:**

- **Единый центр управления:** Подключите счета из нескольких ведущих банков (VBank, ABank, SBank) и управляйте ими из одного интуитивно понятного интерфейса.
- **Продвинутая аналитика на базе ИИ:** Система автоматически категоризирует ваши траты, выявляет паттерны и помогает понять, куда на самом деле уходят ваши деньги. **ИИ-агенты анализируют эти данные, чтобы предоставить глубокие инсайты и прогнозы.**
- **Персональные советы и автоматизация:** На основе анализа ваших данных ИМФС дает конкретные рекомендации: от оптимизации подписок до советов по накоплению и инвестированию. **ИИ-агенты могут также помочь в автоматизации финансовых задач, таких как умное списание или поиск лучших курсов обмена.**
- **Естественно-языковое взаимодействие:** Общайтесь с вашим финансовым советником на естественном языке, задавая вопросы и получая ответы, как если бы вы разговаривали с живым экспертом.
- **Безопасность прежде всего:** Мы используем современные стандарты шифрования (включая сквозное шифрование для токенов доступа) и работаем в строгом соответствии со стандартами OpenBanking.
- **Готовность к будущему:** Наша архитектура легко расширяется для подключения новых банков и финансовых сервисов, а также для интеграции с новыми LLM и ИИ-технологиями.

## Технологический стек Бэкенда

- **Бэкенд:** Python 3.11+ / FastAPI
- **База данных:** PostgreSQL (рекомендуется), SQLite (для простоты запуска)
- **Взаимодействие с API:** `httpx` для асинхронных запросов
- **MCP-сервис:** Центральный компонент для агрегации и унификации взаимодействия с различными банковскими API.
- **ИИ-интеграция:** `Ollama` (для локальных LLM, например, `gemma3:4b`), `LangChain` (для создания ИИ-агентов и инструментов)
- **Безопасность:** `cryptography` для шифрования, `pydantic` для валидации данных
- **Тестирование:** `pytest` (для модульного и интеграционного тестирования)

## Технологический стек UI

-   **Фреймворк:** React 19
-   **Язык:** TypeScript
-   **Стилизация:** Tailwind CSS
-   **AI:** Google AI
-   **Графики:** Recharts

## Архитектура проекта

Проект "Интеллектуальный Мультибанковский Финансовый Советник" (ИМФС) построен на принципах **многослойной (слоистой) архитектуры** и **разделения ответственности (Separation of Concerns)**. Это обеспечивает высокую модульность, масштабируемость, тестируемость и легкость поддержки.

### Основные слои и их назначение:

1.  **`app/api/**` (Слой представления / API Gateway):**
    *   **Назначение:** Отвечает за внешнее взаимодействие с приложением. Определяет публичные HTTP-эндпоинты, используемые фронтендом или другими внешними сервисами. Принимает входящие запросы, выполняет базовую валидацию и маршрутизирует их к соответствующим внутренним сервисам.
    *   **Структура:**
        *   `app/api/v1/__init__.py`: Агрегирует роутеры для различных доменов (auth, data, payments, products, mcp, llm) в единый `api_router`, что позволяет легко управлять версиями API.
        *   `app/api/v1/endpoints/`: Содержит файлы с роутерами FastAPI для конкретных доменов (например, `auth.py`, `data.py`), каждый из которых определяет набор эндпоинтов, связанных с определенной функциональностью.
    *   **Принцип:** **API Gateway / Фасад**. Предоставляет единую точку входа, скрывая сложность внутренней реализации.

2.  **`app/mcp/**` (Слой агрегации / Multi-Bank Communication Protocol Server):**
    *   **Назначение:** Является "сердцем" мультибанковской функциональности. Абстрагирует сложность взаимодействия с различными внешними банковскими API, выступая в роли посредника и унифицируя запросы и ответы от разных банков.
    *   **Структура:**
        *   `app/mcp/router.py`: Определяет эндпоинты, которые позволяют внешним клиентам (включая `llm_integration` модуль) взаимодействовать с несколькими банками через единый интерфейс.
        *   `app/mcp/services.py`: Содержит основную бизнес-логику для взаимодействия с банками: координация запросов к различным `bank_client`'ам, обработка токенов, согласий и унификация ответов.
        *   `app/mcp/schemas.py`: Определяет модели данных (Pydantic) для запросов и ответов, специфичных для мультибанковских операций.
    *   **Принцип:** **Абстракция / Адаптер / Сервис-ориентированная архитектура**. Скрывает детали реализации внешних систем и предоставляет унифицированный интерфейс.

3.  **`app/llm_integration/**` (Слой ИИ-агентов / Интеллектуальный слой):**
    *   **Назначение:** Отвечает за интеграцию с большими языковыми моделями (LLM) и реализацию ИИ-агентов. Предоставляет функциональность для обработки запросов на естественном языке, использования инструментов для взаимодействия с финансовыми данными и генерации интеллектуальных ответов/рекомендаций.
    *   **Структура:**
        *   `app/llm_integration/router.py`: Определяет эндпоинты для взаимодействия с ИИ-агентами (например, чат-интерфейс).
        *   `app/llm_integration/services.py`: Содержит логику инициализации LLM (Ollama), создания LangChain агентов и обработки пользовательских запросов через этих агентов.
        *   `app/llm_integration/tools.py`: Определяет LangChain Tools — обертки вокруг функций, которые ИИ-агенты могут вызывать. Эти инструменты взаимодействуют с `MCPService` для получения финансовых данных.
        *   `app/llm_integration/schemas.py`: Определяет модели данных для запросов и ответов, специфичных для взаимодействия с ИИ-агентами.
    *   **Принцип:** **Интеллектуальный слой / Агент-ориентированная архитектура**. Инкапсулирует всю логику, связанную с ИИ, и предоставляет ее как сервис.

### `app/banks/**` (Слой внешней интеграции с банками):

Эта директория является ключевым слоем для взаимодействия с внешними банковскими API. Она организована по принципу **"Клиент-Сервис"** для каждого банка и **"Домен-ориентированного разделения"** внутри каждого клиента.

1.  **`app/banks/base_client.py` (Базовый клиент):**
    *   **Назначение:** Определяет абстрактный интерфейс (`BaseBankClient`) для всех клиентов банков, гарантируя, что каждый клиент будет иметь определенный набор базовых методов (например, `get_bank_token`, `create_consent`) и свойств (`accounts`, `payments`, `products`).
    *   **Принцип:** **Абстракция / Интерфейс**. Обеспечивает единообразие в работе с разными банками, скрывая их специфику.

2.  **`app/banks/{bank_name}_client.py` (Специфичные клиенты банков):**
    *   **Назначение:** Для каждого конкретного банка (например, `vbank_client.py`, `abank_client.py`, `sbank_client.py`) существует свой класс-клиент, который наследуется от `BaseBankClient`. Эти классы реализуют абстрактные методы `BaseBankClient` в соответствии со спецификой API каждого банка.
    *   **Принцип:** **Полиморфизм / Инкапсуляция**. Каждый клиент инкапсулирует логику взаимодействия с конкретным банком.

3.  **`app/banks/services/` (Доменные сервисы):**
    *   **Назначение:** Внутри каждого клиента банка функциональность разделена на более мелкие, доменные сервисы (например, `accounts`, `payments`, `products`). Это позволяет избежать создания "толстых" классов-клиентов и четко разделить ответственность.
    *   **Структура:**
        *   `app/banks/services/base_service.py`: Базовый класс для всех доменных сервисов, предоставляющий доступ к HTTP-клиенту и URL API.
        *   `app/banks/services/{domain}/base.py`: Абстрактный базовый класс для конкретного домена (например, `BaseAccountsService`), определяющий общий интерфейс для операций в этом домене.
        *   `app/banks/services/{domain}/{bank_name}.py`: Реализация доменного сервиса для конкретного банка (например, `VBankAccountsService` для работы со счетами VBank).
    *   **Принцип:** **Разделение ответственности / Декомпозиция / Сервис-ориентированная архитектура**. Каждая операция (счета, платежи, продукты) для каждого банка имеет свой собственный сервис.

4.  **`app/db/**` (Слой данных / Persistence Layer):**
    *   **Назначение:** Отвечает за взаимодействие с базой данных. Инкапсулирует логику хранения, извлечения и управления данными, такими как токены доступа к банкам.
    *   **Структура:**
        *   `app/db/database.py`: Настраивает подключение к базе данных (SQLAlchemy `engine`, `SessionLocal`) и определяет базовый класс для моделей (`Base`). Также предоставляет функцию-зависимость `get_db()` для FastAPI.
        *   `app/db/models.py`: Определяет ORM-модели SQLAlchemy (например, `Token`) для представления таблиц в базе данных. Здесь описывается структура данных, которые будут храниться.
        *   `app/db/crud.py`: Содержит функции для выполнения операций CRUD (Create, Read, Update, Delete) с данными в базе данных. Например, `save_token` и `get_decrypted_token` для работы с токенами.
    *   **Принцип:** **Репозиторий / Data Access Object (DAO)**. Отделяет бизнес-логику от логики работы с базой данных.

5.  **`app/schemas/**` (Слой схем / Data Transfer Objects):**
    *   **Назначение:** Определяет структуры данных (Pydantic модели) для валидации входящих запросов, формирования исходящих ответов API и обмена данными между различными компонентами приложения. Обеспечивает строгую типизацию и автоматическую валидацию данных.
    *   **Структура:**
        *   `app/schemas/account.py`: Определяет схемы для операций со счетами (например, `AccountCreateRequest`, `AccountDetailsRequest`).
        *   `app/schemas/payment.py`: Определяет схемы для платежей, включая разовые платежи и Variable Recurring Payments (VRP).
        *   `app/schemas/product.py`: Определяет схемы для банковских продуктов и договоров по ним.
    *   **Принцип:** **Data Transfer Object (DTO) / Валидация данных**. Обеспечивает чистоту и предсказуемость данных, проходящих через систему.

### Плюсы такой архитектуры:

1.  **Четкое разделение ответственности (Separation of Concerns):** Каждый модуль имеет четко определенную роль, что делает код более чистым, понятным и легким для поддержки.
2.  **Модульность и переиспользуемость:** Модули относительно независимы и могут быть переиспользованы.
3.  **Масштабируемость:** Позволяет масштабировать каждый компонент независимо.
4.  **Тестируемость:** Каждый слой и компонент может быть протестирован изолированно.
5.  **Гибкость и расширяемость:** Легко добавлять новые банки, LLM, ИИ-агентов, инструменты и версии API.
6.  **Улучшенная читаемость и сопровождаемость:** Четкая структура упрощает навигацию и понимание проекта.
7.  **Снижение связанности (Loose Coupling):** Модули взаимодействуют через четко определенные интерфейсы, минимизируя прямые зависимости.
8.  **Адаптация к специфике API:** Позволяет эффективно обрабатывать уникальные особенности каждого банковского API.

### Пример работы (сквозной поток):

1.  **Входящий запрос:** Пользователь отправляет запрос (например, через фронтенд) на эндпоинт `/api/v1/llm/chat` с вопросом на естественном языке.
2.  **Слой `app/api`:** Принимает запрос, выполняет базовую валидацию и передает его в `app/llm_integration/router.py`.
3.  **Слой `app/llm_integration`:**
    *   `llm_integration/router.py` маршрутизирует запрос к `LLMAgentService`.
    *   `LLMAgentService` использует LangChain агента, который, в свою очередь, использует LLM (Ollama) и набор инструментов.
    *   Агент анализирует запрос пользователя и решает, какой инструмент (из `llm_integration/tools.py`) ему нужно использовать для получения необходимой информации (например, "получить все счета").
4.  **Слой `app/llm_integration/tools.py`:**
    *   Инструмент (например, `get_all_accounts_from_mcp`) вызывается агентом.
    *   Этот инструмент взаимодействует с `MCPService` (из `app/mcp/services.py`).
5.  **Слой `app/mcp`:**
    *   `MCPService` получает запрос от инструмента, определяет, с какими банками нужно взаимодействовать, и координирует запросы к соответствующим `bank_client`'ам.
    *   Он обрабатывает логику получения токенов, согласий и унифицирует ответы от разных банков.
6.  **Слой `app/banks`:**
    *   `MCPService` вызывает методы конкретных `bank_client`'ов (например, `VBankClient.accounts.get_accounts()`).
    *   `VBankClient` и его доменные сервисы (например, `VBankAccountsService`) формируют и отправляют HTTP-запросы к внешнему VBank API, используя `httpx.AsyncClient`.
7.  **Обратный поток:** Ответы от банков возвращаются в `MCPService`, затем в инструмент, затем в LangChain агента, который формирует финальный ответ на естественном языке. Этот ответ возвращается через `llm_integration/router.py` и `app/api` пользователю.

Эта архитектура обеспечивает четкое разделение задач, высокую гибкость и масштабируемость, что критически важно для сложного мультибанковского приложения с интеллектуальными возможностями.

### Предварительная настройка Ollama

Для работы ИИ-агентов требуется локально запущенный сервер Ollama с загруженной моделью `gemma3:4b`. Если у вас еще нет Ollama, выполните следующие шаги:

1.  **Установите Ollama:**
    Следуйте инструкциям на официальном сайте Ollama: [https://ollama.com/download](https://ollama.com/download)

2.  **Загрузите модель `gemma3:4b`:**
    После установки Ollama, откройте терминал и выполните команду:
    ```bash
    ollama pull gemma3:4b
    ```
    Убедитесь, что Ollama сервер запущен перед запуском приложения.

### 1. Установка зависимостей

Убедитесь, что у вас установлен `uv` (сверхбыстрый менеджер пакетов для Python).

```bash
uv pip sync pyproject.toml
```

### 2. Настройка переменных окружения

Создайте файл `.env` в корне проекта. Он должен содержать:

```
CLIENT_ID=your_client_id
CLIENT_SECRET=your_client_secret
ENCRYPTION_KEY=your_32_byte_long_encryption_key
DATABASE_URL=sqlite:///./app.db
```

- `CLIENT_ID`, `CLIENT_SECRET`: Ваши учетные данные для API банков.
- `ENCRYPTION_KEY`: Ключ для шифрования. **Сгенерируйте его командой:**
  ```bash
  python -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())"
  ```
- `DATABASE_URL`: URL для подключения к базе данных.

### 3. Запуск приложения

```bash
uvicorn main:app --reload
```

Сервер будет доступен по адресу `http://127.0.0.1:8000`. Документация OpenAPI (Swagger) — по адресу `http://127.0.0.1:8000/docs`.

## Как проверить работоспособность (workflow)

После запуска приложения вы можете проверить базовый сценарий с помощью `curl`.

**Шаг 1: Инициализация токенов**

Эта команда получит и сохранит в зашифрованном виде токены для всех банков.

```bash
curl -X POST http://127.0.0.1:8000/api/v1/auth/init-bank-tokens -H "Content-Length: 0"
```

**Шаг 2: Создание согласия на доступ к счетам**

Создадим согласие для `vbank`. Это позволит нам читать данные пользователя `team042-1`.

```bash
curl -X POST http://127.0.0.1:8000/api/v1/auth/create-consent -H "Content-Type: application/json" -d \
'{' \
  "bank_name": "vbank",' \
  "user_id": "team042-1",' \
  "permissions": ["ReadAccountsDetail", "ReadBalances"]' \
}'
```

В ответе вы получите `consent_id`. Скопируйте его для следующего шага.

**Шаг 3: Получение списка счетов**

Используем полученный `consent_id` для запроса счетов.

```bash
# Замените ВАШ_CONSENT_ID на ID из предыдущего шага
curl -X POST http://127.0.0.1:8000/api/v1/data/accounts/list -H "Content-Type: application/json" -d \
'{' \
  "bank_name": "vbank",' \
  "consent_id": "ВАШ_CONSENT_ID",' \
  "user_id": "team042-1"' \
}'
```

Если все шаги прошли успешно, вы увидите список счетов. Это подтверждает, что ядро системы работает корректно!

## Запуск тестов

Для полного прогона тестов (часть из них будет пропущена с объяснением причин) выполните:

```bash
PYTHONPATH=. pytest -sv tests/
```

Для запуска всех тестов, включая тесты MCP модуля, выполните:

```bash
PYTHONPATH=. pytest -sv tests/
```
```

## Важные особенности API банков (по итогам тестов)

В ходе интеграции были выявлены следующие особенности API, которые важно учитывать:

- **VBank & ABank:**
  - **Платежи:** Создание платежа возвращает ошибку `403 Forbidden` с сообщением о несоответствии суммы, даже если суммы идентичны. Это **вероятный баг "песочницы"** данных банков.
  - **Управление платежными согласиями:** Попытки получить (`GET`) или отозвать (`DELETE`) созданное платежное согласие приводят к ошибке `401 Unauthorized`. Это с высокой вероятностью указывает на **требование mTLS** для этих эндпоинтов.
  - **Управление согласиями на продукты:** Создание согласия на управление договорами продуктов (`POST /product-agreement-consents/request`) постоянно возвращает ошибку `422 Unprocessable Entity`. Это **вероятный баг "песочницы"** или недокументированные требования API.

- **SBank:**
  - **Любые согласия:** Создание любого типа согласия требует **ручного подтверждения** со стороны пользователя. API возвращает статус `pending`. Это делает невозможным проведение автоматических сквозных тестов.

- **Все банки:**
  - **Управление счетами:** Эндпоинты для прямого управления счетами (создание, изменение статуса) требуют другого типа аутентификации (`client_token`) и в данный момент не используются в основном workflow.

## MCP Server (Multi-Bank Communication Protocol Server)

MCP Server — это центральный компонент нашей мультибанковской платформы, который абстрагирует сложность взаимодействия с различными банковскими API. Он предоставляет унифицированный интерфейс для выполнения операций с несколькими банками, а также служит шлюзом для интеграции с ИИ-чатами.

**Ключевые преимущества и функции MCP Server:**

-   **Унифицированный интерфейс:** Вместо прямого взаимодействия с уникальными API каждого банка, MCP Server предоставляет единый набор эндпоинтов для выполнения общих операций, таких как получение счетов, создание платежей или управление согласиями.
-   **Абстракция сложности:** MCP Server берет на себя все нюансы взаимодействия с различными банками, включая управление токенами, обработку ошибок и специфические требования каждого API.
-   **Мультибанковые операции:** Позволяет выполнять операции сразу с несколькими банками, агрегируя данные и предоставляя их в едином формате.
-   **Интеграция с ИИ-чатами:** Одной из ключевых особенностей MCP Server является его способность служить "мостом" между нашей мультибанковской платформой и интерфейсами ИИ-чатов. Это позволяет пользователям получать информацию о своих финансах и управлять ими, общаясь с ИИ на естественном языке. Например, вы можете спросить: "Сколько денег у меня на всех счетах?" или "Покажи мои последние транзакции в VBank", и ИИ, используя MCP Server, получит и предоставит вам эту информацию.
-   **Централизованное управление согласиями:** MCP Server управляет жизненным циклом согласий (consents) на доступ к данным и выполнение операций, обеспечивая безопасность и соответствие стандартам OpenBanking.
-   **Расширяемость:** Архитектура MCP Server спроектирована таким образом, чтобы легко добавлять поддержку новых банков и финансовых сервисов без изменения логики основного приложения.

## Модуль LLM-интеграции (ИИ-агенты)

Модуль `llm_integration` является ключевым компонентом для реализации интеллектуального финансового советника, позволяя интегрировать возможности больших языковых моделей (LLM) и фреймворка LangChain с нашей мультибанковской платформой. Он открывает путь для создания умных ИИ-агентов, способных анализировать финансовые данные, давать рекомендации и взаимодействовать с пользователем на естественном языке.

**Преимущества модуля:**

-   **Интеллектуальный анализ данных:** ИИ-агенты могут обрабатывать и интерпретировать сложные финансовые данные из различных банков, предоставляя пользователю глубокие инсайты.
-   **Персонализированные рекомендации:** На основе анализа транзакций, счетов и продуктов, агенты могут предлагать индивидуальные финансовые советы, оптимизировать расходы и помогать в достижении финансовых целей.
-   **Естественно-языковое взаимодействие:** Пользователи могут общаться с финансовым советником, задавая вопросы на естественном языке, что делает взаимодействие интуитивно понятным и доступным.
-   **Автоматизация финансовых задач:** В будущем агенты смогут не только давать советы, но и выполнять определенные финансовые операции (например, "умное списание", "умный обмен") по запросу пользователя.
-   **Гибкость и расширяемость:** Архитектура на базе LangChain позволяет легко добавлять новые инструменты и агентов, расширяя функционал ИИ-советника.

**Принципы работы:**

Модуль `llm_integration` использует следующие ключевые технологии и принципы:

-   **Ollama (`gemma3:4b`):** Для локального развертывания и выполнения больших языковых моделей. Это обеспечивает контроль над данными и снижает зависимость от внешних облачных сервисов. Модель `gemma3:4b` выбрана для баланса между производительностью и ресурсоемкостью.
-   **LangChain:** Фреймворк для разработки приложений на базе LLM. LangChain предоставляет инструменты для создания агентов, цепочек (chains) и интеграции LLM с внешними источниками данных и действиями.
-   **ИИ-агенты:** Основной строительный блок модуля. Агенты способны принимать решения о том, какие действия предпринять, используя доступные инструменты, для достижения цели пользователя. Они следуют паттерну ReAct (Reasoning and Acting), который позволяет им рассуждать и выполнять действия.
-   **Инструменты (LangChain Tools):** Это функции, которые ИИ-агенты могут вызывать для взаимодействия с внешним миром. В нашем случае, инструменты являются обертками вокруг эндпоинтов мультибанковского API (через MCP Server). Например, агент может использовать инструмент `get_all_accounts_from_mcp` для получения списка счетов пользователя.

**Тестирование модуля:**

Модуль `llm_integration` сопровождается набором автоматизированных тестов (`tests/test_llm_integration_module.py`), которые проверяют корректность взаимодействия с API и базовую функциональность агента. Тесты используют мокирование для изоляции `LLMAgentService` и проверки его поведения без реального вызова LLM.

**Ключевые преимущества с описанием (вдохновленные UI):**

На основе функционала, представленного в UI, ИИ-агенты могут реализовать следующие возможности:

-   **Финансовый Ассистент:**
    -   **Суммаризация и анализ:** Предоставление сводной информации о финансовом состоянии, анализ трат по категориям, доходов и балансов.
    -   **Ответы на вопросы:** Отвечает на запросы типа "Сколько я потратил на еду в прошлом месяце?", "Какой у меня общий баланс?", "Когда следующий платеж по кредиту?".
    -   **Персональные рекомендации:** Предлагает индивидуальные советы по экономии, инвестициям, оптимизации бюджета на основе анализа данных.
-   **Умное списание:**
    -   **Оптимизация покупки:** Предлагает оптимальный план списания средств для крупной покупки, если на основном счете недостаточно денег, минимизируя потери по процентам на накопительных счетах.
-   **Умный Обмен:**
    -   **Поиск лучшего курса:** Находит самый выгодный курс обмена валют среди всех подключенных банков, учитывая текущие курсы и комиссии.
-   **Умное управление подписками:**
    -   **Отслеживание и оптимизация:** Отслеживает активные подписки, предупреждает о предстоящих списаниях и предлагает варианты оптимизации или отмены.
-   **Умные платежи по кредитам:**
    -   **Оптимизация платежей и рефинансирование:** Помогает оптимизировать ежемесячные платежи по кредитам и ищет более выгодные предложения по рефинансированию.
-   **Платформа доверия:**
    -   **Выявление рисков:** Анализирует условия банковских продуктов и транзакции, выявляя скрытые комиссии, невыгодные ставки и потенциальные риски.

## Справка по API

Ниже представлено описание ключевых эндпоинтов, доступных в сервисе.

### Общие эндпоинты

- `GET /`: Корневой эндпоинт.
- `GET /health`: Эндпоинт для проверки работоспособности сервиса.
- `GET /.well-known/jwks.json`: JWKS эндпоинт - публичные ключи банка для проверки JWT подписей при межбанковских запросах.

### Аутентификация и Согласия

- `POST /api/v1/auth/init-bank-tokens`: Инициализация токенов.
- `POST /api/v1/auth/create-consent`: Создание согласия на доступ к данным.
- `POST /api/v1/payments/payment-consents`: Создание согласия на **платеж**.
- `GET /api/v1/auth/consents/{id}`: Получение информации о согласии на **доступ**.
- `DELETE /api/v1/auth/consents/{id}`: Отзыв согласия на **доступ**.

### Данные

- `POST /api/v1/data/accounts/list`: Получение списка счетов.
- `POST /api/v1/data/accounts/{id}/balances`: Получение балансов счета.
- `POST /api/v1/data/accounts/{id}/transactions`: Получение транзакций счета.

### Платежи

- `POST /api/v1/payments/{bank_name}/create`: Создание нового платежа.
- `GET /api/v1/payments/{bank_name}/{id}/status`: Получение статуса платежа.
- `GET /api/v1/payments/payment-consents/{id}`: Получение информации о согласии на **платеж**.
- `DELETE /api/v1/payments/payment-consents/{id}`: Отзыв согласия на **платеж**.

### Продукты

- `GET /api/v1/products/products`: Получение каталога банковских продуктов.
- `GET /api/v1/products/products/{product_id}`: Получение деталей продукта.
- `POST /api/v1/products/product-agreement-consents/request`: Создание согласия на управление договорами продуктов.
- `GET /api/v1/products/product-agreement-consents/{consent_id}`: Получение деталей согласия на управление договорами продуктов.
- `DELETE /api/v1/products/product-agreement-consents/{consent_id}`: Отзыв согласия на управление договорами продуктов.
- `GET /api/v1/products/product-agreements`: Получение списка договоров клиента по продуктам.
- `POST /api/v1/products/product-agreements`: Открытие нового продукта (создание договора).
- `GET /api/v1/products/product-agreements/{agreement_id}`: Получение деталей конкретного договора по продукту.
- `DELETE /api/v1/products/product-agreements/{agreement_id}`: Закрытие (расторжение) договора по продукту.
